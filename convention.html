<h1>Conventions and Coding Style</h1>

<p>Following Despark's coding style is mandatory. This makes code more readable and allows for easier code sharing and contributing inside the team. 
<em>* Following this conventions will make yours and the lives of everybody in the company easier *</em></p>

<h2>Class Names and File Location</h2>

<p>Class names in Kohana follow a strict convention to facilitate autoloading. Class names should have uppercase first letters with underscores to separate words. Underscores are significant as they directly reflect the file location in the filesystem.</p>

<p>The following conventions apply:</p>

<ol>
<li>CamelCased class names should be used when it is undesirable to create a new directory level.</li>
<li>All class file names and directory names must match the case of the class as per PSR-0.</li>
<li>All classes should be in the classes directory. This may be at any level in the cascading filesystem.</li>
</ol>

<h3>Examples</h3>

<p>Remember that in a class, an underscore means a new directory. Consider the following examples:</p>

<h1>Coding Standards</h1>

<p>In order to produce highly consistent source code, we ask that everyone follow the coding standards as closely as possible.</p>

<h2>Brackets</h2>

<p>Please use BSD/Allman Style bracketing.</p>

<h3>Curly Brackets</h3>

<p>Curly brackets are placed on their own line, indented to the same level as the control statement.</p>

<pre><code>// Correct
if ($a === $b)
{
    ...
}
else
{
    ...
}

// Incorrect
if ($a === $b) {
    ...
} else {
    ...
}
</code></pre>

<h3>Class Brackets</h3>

<p>The only exception to the curly bracket rule is, the opening bracket of a class goes on the same line.</p>

<pre><code>// Correct
class Foo {

// Incorrect
class Foo
{
</code></pre>

<h3>Empty Brackets</h3>

<p>Don't put any characters inside empty brackets.</p>

<pre><code>// Correct
class Foo {}

// Incorrect
class Foo { }
</code></pre>

<h3>Array Brackets</h3>

<p>Arrays may be single line or multi-line.</p>

<pre><code>array('a' =&gt; 'b', 'c' =&gt; 'd')

array(
    'a' =&gt; 'b', 
    'c' =&gt; 'd',
)
</code></pre>

<h4>Opening Parenthesis</h4>

<p>The opening array parenthesis goes on the same line.</p>

<pre><code>// Correct
array(
    ...
)

// Incorrect:
array
(
    ...
)
</code></pre>

<h4>Closing parenthesis</h4>

<h5>Single Dimension</h5>

<p>The closing parenthesis of a multi-line single dimension array is placed on its own line, indented to the same level as the assignment or statement.</p>

<pre><code>// Correct
$array = array(
    ...
)

// Incorrect
$array = array(
    ...
    )
</code></pre>

<h5>Multidimensional</h5>

<p>The nested array is indented one tab to the right, following the single dimension rules.</p>

<pre><code>// Correct
array(
    'arr' =&gt; array(
        ...
    ),
    'arr' =&gt; array(
        ...
    ),
)

array(
    'arr' =&gt; array(...),
    'arr' =&gt; array(...),
)
</code></pre>

<h4>Arrays as Function Arguments</h4>

<pre><code>// Correct
do(array(
    ...
))

// Incorrect
do(array(
    ...
    ))
</code></pre>

<p>As noted at the start of the array bracket section, single line syntax is also valid.</p>

<pre><code>// Correct
do(array(...))

// Alternative for wrapping long lines
do($bar, 'this is a very long line',
    array(...));
</code></pre>

<h3>Naming Conventions</h3>

<p>Kohana uses under_score naming, not camelCase naming.</p>

<h4>Classes</h4>

<pre><code>// Controller class, uses Controller_ prefix
class Controller_Apple extends Controller {

// Model class, uses Model_ prefix
class Model_Cheese extends Model {

// Regular class
class Peanut {
</code></pre>

<p>When creating an instance of a class, don't use parentheses if you're not passing something on to the constructor:</p>

<pre><code>// Correct:
$db = new Database;

// Incorrect:
$db = new Database();
</code></pre>

<h4>Functions and Methods</h4>

<p>Functions should be all lowercase, and use under_scores to separate words:</p>

<pre><code>function drink_beverage($beverage)
{
</code></pre>

<h4>Variables</h4>

<p>All variables should be lowercase and use under_score, not camelCase:</p>

<pre><code>// Correct:
$foo = 'bar';
$long_example = 'uses underscores';

// Incorrect:
$weDontWantThis = 'understood?';
</code></pre>

<h3>Indentation</h3>

<p>You must use tabs to indent your code. Using spaces for tabbing is strictly forbidden.</p>

<p>Vertical spacing (for multi-line) is done with spaces. Tabs are not good for vertical alignment because different people have different tab widths.</p>

<pre><code>$text = 'this is a long text block that is wrapped. Normally, we aim for '
      .'wrapping at 80 chars. Vertical alignment is very important for '
      .'code readability. Remember that all indentation is done with tabs,'
      .'but vertical alignment should be completed with spaces, after '
      .'indenting with tabs.';
</code></pre>

<h3>String Concatenation</h3>

<p>Do NOT put spaces around the concatenation operator:</p>

<pre><code>// Correct:
$str = 'one'.$var.'two';

// Incorrect:
$str = 'one' . $var . 'two';
$str = 'one'. $var .'two';
</code></pre>

<h3>Single Line Statements</h3>

<p>Single-line IF statements should only be used when breaking normal execution (e.g. return or continue):</p>

<pre><code>// Acceptable:
if ($foo == $bar)
    return $foo;

if ($foo == $bar)
    continue;

if ($foo == $bar)
    break;

if ($foo == $bar)
    throw new Exception('You screwed up!');

// Not acceptable:
if ($baz == $bun)
    $baz = $bar + 2;
</code></pre>

<h3>Comparison Operations</h3>

<p>Please use AND / OR logical operators for comarison:</p>

<pre><code>// Correct:
if (($foo AND $bar) OR ($b AND $c))

// Incorrect:
if (($foo == $bar) || ($b == $c))
</code></pre>

<p>Please use elseif, not else if:</p>

<pre><code>// Correct:
elseif ($bar)

// Incorrect:
else if($bar)
</code></pre>

<h4>Switch Structures</h4>

<p>Each case, break and default should be on a separate line. The block inside a case or default must be indented by 1 tab.</p>

<pre><code>switch ($var)
{
    case 'bar':
    case 'foo':
        echo 'hello';
    break;
    case 1:
        echo 'one';
    break;
    default:
        echo 'bye';
    break;
}
</code></pre>

<h3>Parentheses</h3>

<p>There should be one space after statement name, followed by a parenthesis. The ! (bang) character must have a space on either side to ensure maximum readability. Except in the case of a bang or type casting, there should be no whitespace after an opening parenthesis or before a closing parenthesis.</p>

<pre><code>// Correct:
if ($foo == $bar)
if ( ! $foo)

// Incorrect:
if($foo == $bar)
if(!$foo)
if ((int) $foo)
if ( $foo == $bar )
if (! $foo)
</code></pre>

<h3>Ternaries</h3>

<p>All ternary operations should follow a standard format. Use parentheses around expressions only, not around just variables.</p>

<pre><code>$foo = ($bar == $foo) ? $foo : $bar;
$foo = $bar ? $foo : $bar;
</code></pre>

<p>All comparisons and operations must be done inside of a parentheses group:</p>

<pre><code>$foo = ($bar &gt; 5) ? ($bar + $foo) : strlen($bar);
</code></pre>

<p>When separating complex ternaries (ternaries where the first part goes beyond ~80 chars) into multiple lines, spaces should be used to line up operators, which should be at the front of the successive lines:</p>

<pre><code>$foo = ($bar == $foo)
     ? $foo
     : $bar;
</code></pre>

<h3>Type Casting</h3>

<p>Type casting should be done with spaces on each side of the cast:</p>

<pre><code>// Correct:
$foo = (string) $bar;
if ( (string) $bar)

// Incorrect:
$foo = (string)$bar;
</code></pre>

<p>When possible, please use type casting instead of ternary operations:</p>

<pre><code>// Correct:
$foo = (bool) $bar;

// Incorrect:
$foo = ($bar == TRUE) ? TRUE : FALSE;
</code></pre>

<p>When casting type to integer or boolean, use the short format:</p>

<pre><code>// Correct:
$foo = (int) $bar;
$foo = (bool) $bar;

// Incorrect:
$foo = (integer) $bar;
$foo = (boolean) $bar;
</code></pre>

<h3>Constants</h3>

<p>Always use uppercase for constants:</p>

<pre><code>// Correct:
define('MY_CONSTANT', 'my_value');
$a = TRUE;
$b = NULL;

// Incorrect:
define('MyConstant', 'my_value');
$a = True;
$b = null;
</code></pre>

<p>Place constant comparisons at the end of tests:</p>

<pre><code>// Correct:
if ($foo !== FALSE)

// Incorrect:
if (FALSE !== $foo)
</code></pre>

<p>This is a slightly controversial choice, so I will explain the reasoning. If we were to write the previous example in plain English, the correct example would read:</p>

<pre><code>if variable $foo is not exactly FALSE
</code></pre>

<p>And the incorrect example would read:</p>

<pre><code>if FALSE is not exactly variable $foo
</code></pre>

<p>Since we are reading left to right, it simply doesn't make sense to put the constant first.</p>

<h3>Comments</h3>

<h4>One-line Comments</h4>

<p>Use //, preferably above the line of code you're commenting on. Leave a space after it and start with a capital. Never use #.</p>

<pre><code>// Correct

//Incorrect
// incorrect
# Incorrect
</code></pre>

<h3>Regular Expressions</h3>

<p>When coding regular expressions please use PCRE rather than the POSIX flavor. PCRE is considered more powerful and faster.</p>

<pre><code>// Correct:
if (preg_match('/abc/i', $str))

// Incorrect:
if (eregi('abc', $str))
</code></pre>

<p>Use single quotes around your regular expressions rather than double quotes. Single-quoted strings are more convenient because of their simplicity. Unlike double-quoted strings they don't support variable interpolation nor integrated backslash sequences like 
 or     , etc.</p>

<pre><code>// Correct:
preg_match('/abc/', $str);

// Incorrect:
preg_match("/abc/", $str);
</code></pre>

<p>When performing a regular expression search and replace, please use the $n notation for backreferences. This is preferred over 
.</p>

<pre><code>// Correct:
preg_replace('/(\d+) dollar/', '$1 euro', $str);

// Incorrect:
preg_replace('/(\d+) dollar/', '\1 euro', $str);
</code></pre>

<p>Finally, please note that the $ character for matching the position at the end of the line allows for a following newline character. Use the D modifier to fix this if needed. More info.</p>

<pre><code>$str = "email@example.com&lt;script type="text/javascript"&gt;
/* &lt;![CDATA[ */
(function(){try{var s,a,i,j,r,c,l,b=document.getElementsByTagName("script");l=b[b.length-1].previousSibling;a=l.getAttribute('data-cfemail');if(a){s='';r=parseInt(a.substr(0,2),16);for(j=2;a.length-j;j+=2){c=parseInt(a.substr(j,2),16)^r;s+=String.fromCharCode(c);}s=document.createTextNode(s);l.parentNode.replaceChild(s,l);}}catch(e){}})();
</code></pre>

<p>/* ]]> */
    </script>
";</p>

<pre><code>preg_match('/^.+@.+$/', $str);  // TRUE
preg_match('/^.+@.+$/D', $str); // FALSE
</code></pre>

